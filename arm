1. arm架构
2. arm开发板
3. arm-linux嵌入式开发
网上推荐书籍：《ARM嵌入式系统开发-软件设计与优化》《ARM体系结构与编程》（尚未找到资源）特别是第一本，获得一致好评。

1. arm架构基础知识
顾名思义（advanced risc machine), arm是一款廉价、高性能、耗能低的risc微处理器内核。
rics和cisc
risc（reduced instuction set computing)：精简指令集。
cisc（complex instruction set computing）复杂指令集
我们并不需要比较risc和cisc的优劣。arm处理器所使用的指令集是risc

cpu和soc
soc：system on chip片上系统
芯片发展的方向是从cpu到soc，就是把cpu和各种外设集成到芯片中去，从而提高集成度。
ARM公司出售的是内核（cpu）本身，各种外设是半导体厂商自己添加进芯片的

arm 处理器系列
芯片代号为A系列：如 Cortex-A8 , Cortex-A9。应用于高端产品的芯片，如智能手机等。
芯片代号为R系列：如如 Cortext-R4。应用于一些对性能要求稍微低一些的设备。
芯片代号为M系列：Cortext-M 系列。应用于性能要求更低的设备。
A系列和R系列比较相像，但和M系列有着本质区别

arm体系架构
1、ARMv4
2、ARMv5
3、ARMv6
4、ARMv7
不同体系架构拥有不同的指令集。

arm内部架构
可以把arm视为小型计算机。对于计算机组成我们都比较熟悉，包括CPU和存储系统，一个用来计算，一个用来存和取。而存储系统又分为主存（ram）和外存（rom），严格意义上来说存储系统还包括集成在CPU内部的缓存（cache）
因此一个典型的arm至少包括三个模块：
1. cpu
2. 主存
3. flash

冯诺依曼结构和哈佛结构
这两种结构都是基于存储式的结构。冯诺依曼结构是程序指令和数据存储在相同的地方；而哈佛结构把程序指令和其他数据分开存储。
冯诺依曼结构
冯诺依曼结构指导了存储设备和中央处理器分开的思想，就是把计算和存储分开的思想。
基于存储的计算机器打破了有限状态机的束缚，借助创造的指令集架构，将所谓的运算转化成一串程序指令的执行细节，并能在程序控制下对数据（计算结果和计算内容）进行修改，实现了真正意义上的“软件”。
由于程序指令存储地址和数据存储地址指向的是同一个存储器，因此程序指令和数据的宽度是相同的。
冯诺依曼结构存在的风险：由于程序指令和数据存储在同一个地方，有些恶意程序就有可能通过输入数据（input）来覆盖重写程序指令，从而达到控制系统的目的。这便是“buffer overflow”。
冯诺依曼瓶颈：其实是基于存储的计算机器存在的普遍问题，本质上是由cpu计算速度和存储器的访问速度越来越不匹配导致的。cpu计算速度越来越快，而访存速度远远跟不上cpu速度的发展，导致cpu经常在等待数据到来处于空闲状态，特别是在需要大量访问内存的时候，从而限制了总吞吐量的大小。
缓解这一矛盾的方案有CPU缓存系统的设计。还有哈佛结构也是缓解这一矛盾的方案。还有分支预测等技术。
哈佛结构把程序指令和数据分开存储，使得在执行程序指令的时候或者等数据的时候，可以预先读取下一条指令，从而提高cpu的利用率。很多专用DSP采用的是哈佛结构。
但是通用处理器采用的是“Modified harvard architecture”，在内存里指令和数据是在一起的。而在CPU内的缓存区分指令缓存和数据缓存。


arm总线
地址总线，决定了cpu的寻址能力。
存取数据就需要知道数据存放的位置，该地址信息是通过地址总线传输的。
地址总线有n条，我们叫做地址总线有n位，最大寻址范围为2^n个byte。因此地址总线的位数决定了cpu的寻址能力。
数据总线，顾名思义，是数据传输的通道。
假设数据总线有m条，每条传输线一次只能传输1位二进制数，我们叫做数据总线宽度有m位，则传输的数据或者指令也有m位。
字长指cpu同一时间内可以处理的二进制数的位数，为了cpu的利用率，所以数据总线的宽度和字长总是一致的。
数据总线的宽度 = 字长 = cpu的位数
arm架构的cpu通常是32位的

存储系统（rom和ram）
半导体存储器有一个典型的特点：容量大的速度慢，容量小的速度快。
需要容量又大速度又快，付出的将会是高昂的造价。目前的解决方案是使用多层级的存储系统（寄存器-cache-主存-外存-其他主机）。
ram：断电易失。dram（主存），sram（缓存）
rom：断电不易失。disk，flash， ssd等

具体的更深入的arm架构需要结合实际开发板。

3. arm-linux嵌入式开发
单片机开发和嵌入式开发的主要区别在于，功能的复杂度，和外设的复杂度
单片机开发：多涉及一些简单的外设，譬如串口、I2C、ADC、LCD（小屏幕和分辨率）；
嵌入式开发：涉及更多复杂外设，譬如网络（有线网卡、wifi、蓝牙等）、USB、音视频编解码等。

！基础开发流程：
嵌入式开发，A(类)机编写（源代码）、编译得到可执行程序，发布给B(类)机运行。
交叉编译导致的问题是，不便于本机运行调试程序。可能需要借用专用的调试器实现单步调试。

！基础知识与技能：
*开发环境
交叉编译工具链（arm-linux-gcc）的掌握；
集成开发环境

*arm启动流程
arm启动代码的编写
掌握 BootLoader 的移植
定制化linux内核，如何使用bootloader传递启动参数启动内核

BootLoader
是一个引导程序，作用很简单：加载内核。说白了，就是让内核代码常驻内存，并得到执行。
每一种cpu都有自己的启动方式：
1）上电后从rom读固定长度的代码到ram，然后跳到ram里进行执行。这就是boot
2）为了拷贝更多的代码，首先进入ram的功能代码是一个加载器（loader）。这就是bootloader。uboot是嵌入式开发中最常使用的bootloader。
很多嵌入式教程都推荐通过uboot的学习来认识和理解arm系统架构和内核。

*Linux内核
交叉编译：arm-linux-gcc
BSP：外设驱动集合。比如扩了一个串口/wifi，需要编写设备驱动。
Kconfig：可选模块和功能编译进内核里
镜像制作和烧写：内核镜像是被bootloader加载的，比如u-boot可以把内核镜像加载到RAM并执行。制作u-boot可加载的镜像需要使用mkimage工具。

*驱动开发
裸机驱动开发（时钟初始化，内存初始化，nandflash的操作，MMU，LCD驱动）
linux外设驱动开发（GPIO、UART、I2C、wifi）
简单的驱动开发，如 GPIO等外设的驱动
复杂的驱动开发，如 网卡、wifi等外设的驱动
内核代码的阅读（目标是理解系统，也为了驱动性能）

*硬件：
1. 明确qca驱动跑起来所必须的硬件外设。和arm开发板的硬件资源比较，有哪些是有差异的，有哪些是欠缺的，硬件资源方面是否存在瓶颈。








